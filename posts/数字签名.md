---
title: '数字签名 和 https协议'
date: '2020-09-25'
kind: 'Base'
---

### 非对称加密（信息保密）

鉴于 **对称加密(如AES算法)** 的安全性不足（解密加密同一个密钥），**非对称加密（也叫`Diffie-Hellman`密钥交换算法）**是指：产生两把密钥，这一对公私钥**有且仅有唯一**的配对。公钥包含私钥的信息，但是掺杂其他随机变量，因此如果要反推需要大量的计算和时间，其不可反推的特性被当做安全性的保障。著名的有`RSA算法`，理论上秘钥超过1024位，就可以认为是安全。

> 服务器端（后面统称为Server），客户端（后面统称为Client）

公钥私钥都可以用作加密(严格意义上私钥是用来签名的)，具体用哪个钥加密需要看情况： 

- 如果只是希望**信息保密**，不想让别人知道，应该由 **对方** 用 **我的** 公钥进行加密 ，只有我的 **私钥** 才能解开，只要我私钥不泄露，理论上我是**绝对安全**的； (加密用**公钥**,保证文件即使泄露,别人也无法破解)

- 如果只是希望 **证明信息是你发出** ，那么你应该用 **我的** 私钥**签名**，对方用 **我的** 公钥**验签**，这个做法可以保证 **信息一定是我发出的** ，但是，由于是用我的 **私钥加密**，那么所以拥有我的公钥的人都可以看到我们的通信，**虽不可抵赖，但却无法保密**。(签名用**私钥**, 信息是公开的,但是保证了文件一定是**没被篡改**)

鉴于以上 只有一对公私钥的情况不能**绝对保证安全**下，数字签名概念就诞生了。



### **数字签名**（防止信息篡改）

>  一句话， 从 **报文的原文** 通过HASH散列函数得出摘要， **摘要（Digest）**通过 **加密**，就得到**数字签名**

HASH散列函数如SHA1 、SHA256



总过程： 

数字签名在Server，分成三步。

 1）从 **原文** 算出 **摘要**（HASH算法 如: SHA-1 SHA-256） 

 2）**摘要** 通过签名(用Server的私钥签名) 变成 **数字签名**。（Server私钥）。  

 3）把 **原文 配上 数字签名** 一起发送



数字签名在Client，分成两步。 

1）从 **数字签名** 解密出 **摘要明文** （使用Server公钥） 

2）从收到的 **原文** 当场计算摘要（HASH算法） ，与1）得出的摘要明文对比，是否一致。



如果一致，可以说明两点：

（1）内容未被篡改（摘要一致）

（2）内容只能是私钥拥方发送，不可抵赖（密文能够用对方的公钥解开）



**所以数字签名 有 不可抵赖+无法仿冒 的作用** ，通过这个方式，我们可以解决 **信息被篡改** 的问题



### 数字证书（保证公钥传输安全）

上面的两种方法一起使用，似乎已经达到很安全的程度了：发送方的信息不会被仿冒，也不可抵赖，只要大家都用数字签名，就可以达到完全安全的程度。*万一双方交换的公钥，被人掉包了呢？*



问题又从 **如何保障报文信息安全，变成如何保障公钥安全** 。为了保证 “公钥”是可信的，CA证书就诞生了。

CA是第三方机构，CA公钥是公开的，接收方在**系统预装，浏览器预装**中可以确认CA的根证书，也可以跟别人比对（比如在网上查询），因此不可能伪造。



**网站的服务器（后面统称为Server）**先把自己的公钥，提交给CA，CA用 **私钥** 对其进行签名得到 **加密后的发送方公钥**（用的是CA的私钥和CA加密算法），也就是**CA的数字证书**。CA颁发的证书包含：**签发者，证书用途，server的公钥，server的加密算法，server的HASH算法，证书到期时间**等信息，通过`数字签名` 的方式，把**原始信息**和**签名**都放在数字证书里。



数字证书包含了**Server的公钥**, 通过使用CA的 **公钥** 验签的方式,可以确保信息没有被改动，同时准确的获取Server的公钥, 在一定程度上防止了公钥被掉包的情况.(但是证书也可能会被掉包,比如著名的中间人攻击.使用charles等代理抓包时也需要安装可信任的RootCA证书,因为抓包软件本质上也是中间人)



Server 不仅发送内容、数字签名，**还包含Server的数字证书**。Client拿到后，**首先从数字证书中解密出发送方公钥**（用的是CA的公钥和CA解密算法），**这个公钥必然是可信的**。然后就是和前面一样的流程，拿Server公钥去解密数字证书，得到摘要；最后比对摘要是否一致。



### Https的通信流程

基于SSL/TLS协议（它是采取公钥加密算法），从而使http可以通过加密通信方式避免 **信息泄露，篡改信息，中间人攻击**

SSL协议（Secure Sockets Layer）目前都是使用 **3.0以上**版本，而`TLS1.0` 使用最广泛，它也被称为`SSL3.1` 

两者对应关系为

| SSL  | TLS  |
| ---- | ---- |
| 3.1  | 1.0  |
| 3.2  | 1.1  |
| 3.3  | 1.2  |

总结以上的 `非对称加密`，`数字证书`，模拟一次https的流程

握手阶段（所有通信都是明文的）

   1. Client发出加密通信请求，叫做`ClientHello请求`

      - 发送信息：

        1. 支持的协议版本，比如TLS 1.0版。

        2. 一个客户端生成的随机数 str1，用于生成"session key"。

        3. 支持的加密方法，比如RSA公钥加密。

        4. 支持的压缩方法

   2. Server回应，叫做`SeverHello请求`

      - 发送信息：
        1. 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
        2. 一个服务器生成的随机数 str2，用于生成"session key"。
        3. 确认使用的加密方法，比如RSA公钥加密。
        4. 服务器证书。（CA认证的，给到服务器的证书）

   3. Client 回应

      - 先验证`服务器证书` （数字签名流程），从证书上颁发的CA机构中检查，用CA提供的公钥验证，如果证书**不是可信机构颁布**、或者**证书中的域名与实际域名不一致**、或者**证书已经过期** ，会提出一个警告⚠️，让操作者决定是否继续操作。
      - 证书没问题，会拿出证书里的`Server公钥`, 然后回应给Server
        - 发送信息
          1. 一个随机数。该随机数用**服务器公钥加密**，防止被窃听。（非对称算法，公钥加密只能私钥解密）
          2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（对称算法，约定好key值以后用对称算法通信）
          3. Client握手结束通知，表示Clinet的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供Server校验。

   4. Server的最后回应
      - 根据三个`pre-master key` ，计算生成本次会话所用的"会话密钥（session key）"，用于对称算法的秘钥
      - 发送信息
        1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（对称加密算法和session key的确认）
        2. Server握手结束通知，表示Server的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供Client校验。

自此，握手阶段结束，接下来就是Server和Client进入加密通信，就是完全使用http协议了，只不过这里通过`session key` 加密内容。



